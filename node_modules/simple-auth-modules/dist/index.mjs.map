{"version":3,"sources":["../src/dbConnection.ts","../src/model/userModel.ts","../src/userRegister.ts"],"sourcesContent":["import mongoose from 'mongoose';\n\ntype ConnectionURI = string;\n\nexport const dbConnection = async (connectionString: ConnectionURI): Promise<void> => {\n  try {\n    mongoose.set('strictQuery', true);\n    await mongoose.connect(connectionString);\n    console.log('Database is connected');\n  } catch (err) {\n    console.error('Connection failed:', err);\n    throw err; \n  }\n};\n","import mongoose, { Document, Model, Schema } from 'mongoose';\n\ninterface IUser {\n  username: string;\n  email: string;\n  password: string;\n}\n\nexport interface IUserModel extends IUser, Document {}\n\nconst userSchema = new mongoose.Schema<IUserModel>({\n  username: { type: String, required: true },\n  email: { type: String, required: true },\n  password: { type: String, required: true },\n});\n\nconst UserModel: Model<IUserModel> = mongoose.model<IUserModel>('User', userSchema);\n\nexport { UserModel };\n","import { UserModel } from \"./model/userModel\";\nimport { IUserModel } from \"./model/userModel\";\nimport bcrypt from 'bcrypt';\nimport jwt from 'jsonwebtoken';\n\ninterface IUser {\n  username: string;\n  email: string;\n  password: string;\n}\n\nexport const registerUser = async (userData: IUser): Promise<IUserModel> => {\n  const hashedPassword = await bcrypt.hash(userData.password, 10);\n  const user = new UserModel({\n    username: userData.username,\n    email: userData.email,\n    password: hashedPassword,\n  });\n  return user.save();\n};\n\nexport const loginUser = async (username: string, password: string, secretKey: string): Promise<string | null> => {\n  const user = await UserModel.findOne({ username });\n  if (user && await bcrypt.compare(password, user.password)) {\n    const token = generateToken(user, secretKey);\n    return token;\n  }\n\n  return null;\n};\n\nexport const verifyToken = (token: string, secretKey: string): { userId: string; username: string; email: string } | null => {\n  try {\n    const decoded = jwt.verify(token, secretKey) as { userId: string; username: string; email: string };\n    return decoded;\n  } catch (error) {\n    console.error('Error verifying token:', error);\n    return null;\n  }\n};\n\nconst generateToken = (user: any, secretKey: string): string => {\n  const token = jwt.sign(\n    { userId: user._id, username: user.username, email: user.email },\n    secretKey,\n    { expiresIn: '1h' }\n  );\n  return token;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,cAAc;AAId,IAAM,eAAe,CAAO,qBAAmD;AACpF,MAAI;AACF,aAAS,IAAI,eAAe,IAAI;AAChC,UAAM,SAAS,QAAQ,gBAAgB;AACvC,YAAQ,IAAI,uBAAuB;AAAA,EACrC,SAAS,KAAK;AACZ,YAAQ,MAAM,sBAAsB,GAAG;AACvC,UAAM;AAAA,EACR;AACF;;;ACbA,OAAOA,eAA2C;AAUlD,IAAM,aAAa,IAAIA,UAAS,OAAmB;AAAA,EACjD,UAAU,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACzC,OAAO,EAAE,MAAM,QAAQ,UAAU,KAAK;AAAA,EACtC,UAAU,EAAE,MAAM,QAAQ,UAAU,KAAK;AAC3C,CAAC;AAED,IAAM,YAA+BA,UAAS,MAAkB,QAAQ,UAAU;;;ACdlF,OAAO,YAAY;AACnB,OAAO,SAAS;AAQT,IAAM,eAAe,CAAO,aAAyC;AAC1E,QAAM,iBAAiB,MAAM,OAAO,KAAK,SAAS,UAAU,EAAE;AAC9D,QAAM,OAAO,IAAI,UAAU;AAAA,IACzB,UAAU,SAAS;AAAA,IACnB,OAAO,SAAS;AAAA,IAChB,UAAU;AAAA,EACZ,CAAC;AACD,SAAO,KAAK,KAAK;AACnB;AAEO,IAAM,YAAY,CAAO,UAAkB,UAAkB,cAA8C;AAChH,QAAM,OAAO,MAAM,UAAU,QAAQ,EAAE,SAAS,CAAC;AACjD,MAAI,SAAQ,MAAM,OAAO,QAAQ,UAAU,KAAK,QAAQ,IAAG;AACzD,UAAM,QAAQ,cAAc,MAAM,SAAS;AAC3C,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,cAAc,CAAC,OAAe,cAAkF;AAC3H,MAAI;AACF,UAAM,UAAU,IAAI,OAAO,OAAO,SAAS;AAC3C,WAAO;AAAA,EACT,SAAS,OAAO;AACd,YAAQ,MAAM,0BAA0B,KAAK;AAC7C,WAAO;AAAA,EACT;AACF;AAEA,IAAM,gBAAgB,CAAC,MAAW,cAA8B;AAC9D,QAAM,QAAQ,IAAI;AAAA,IAChB,EAAE,QAAQ,KAAK,KAAK,UAAU,KAAK,UAAU,OAAO,KAAK,MAAM;AAAA,IAC/D;AAAA,IACA,EAAE,WAAW,KAAK;AAAA,EACpB;AACA,SAAO;AACT;","names":["mongoose"]}